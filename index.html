<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Study Watcher Pro (COCO-SSD版)</title>
<style>
  :root { color-scheme: light dark; }
  html, body { height: 100%; }
  body { margin: 0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Sans", "Noto Sans JP", sans-serif; background: Canvas; color: CanvasText; }
  header { padding: 12px 16px; border-bottom: 1px solid #ddd; position: sticky; top: 0; background: inherit; z-index: 2; }
  main { padding: 12px 16px; }
  .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
  video { width: 100%; max-height: 44vh; background: #000; border-radius: 12px; }
  .pill { padding: 6px 10px; border-radius: 999px; border: 1px solid #ccc; font-size: 14px; }
  .ok { background: #e7f7ee; border-color: #a3d8bf; }
  .ng { background: #fdeaea; border-color: #f2b7b7; }
  button { padding: 10px 14px; border-radius: 10px; border: 1px solid #ccc; font-size: 16px; background: ButtonFace; color: ButtonText; }
  .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px; }
  small { color: #666; }
  #log { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; opacity: .85; }
  /* フルスクリーン時の見た目 */
  .fs header { display: none; }
  .fs main { padding: 0; }
  .fs video { max-height: none; height: 100vh; border-radius: 0; }
  .fs .floating-bar { position: fixed; bottom: 10px; left: 0; right: 0; display: flex; gap: 8px; justify-content: center; z-index: 3; }
  .floating-bar button { opacity: .9; backdrop-filter: blur(6px); }
  /* 横向きのときだけ適用 */
  @media (orientation: landscape) {
  /* ヘッダーのピル（バッジ）を横スクロール可にして潰れ防止 */
  header .row { flex-wrap: nowrap; overflow-x: auto; white-space: nowrap; gap: 8px; }
  .pill { font-size: 12px; padding: 4px 8px; }

  /* メインは2カラム：左=映像 右=操作&ログ */
  main { 
    padding: 8px 12px; 
    display: grid; 
    grid-template-columns: 1.4fr 1fr; 
    gap: 12px; 
    align-items: start; 
  }

  /* 映像は縦いっぱい（安全余白を少し引く） */
  video { 
    max-height: none; 
    height: calc(100vh - 90px); /* 端末により ± 調整してOK */
    border-radius: 10px;
  }

  /* ボタンのグリッドや入力幅をコンパクトに */
  .grid { grid-template-columns: 1fr 1fr; gap: 8px; }
  label.pill input { width: 56px !important; }
}

</style>
</head>
<body>
<header>
  <div class="row">
    <strong>Study Watcher Pro</strong>
    <span id="statePill" class="pill ng">停止中</span>
    <span id="personPill" class="pill">人: 未検出</span>
    <span id="phonePill" class="pill">スマホ: 未検出</span>
    <span id="scorePill" class="pill">スコア: 0</span>
    <span id="minutePill" class="pill">勉強分: 0</span>
  </div>
</header>

<main>
  <video id="video" playsinline muted></video>

  <div class="grid">
    <button id="startBtn">開始</button>
    <button id="stopBtn" disabled>停止</button>
  </div>

  <div class="row" style="margin-top:8px;">
    <label class="pill">在席しきい値: <input id="presence" type="number" min="50" max="100" step="5" value="70" style="width:64px;">%</label>
    <label class="pill">送信間隔: <input id="flush" type="number" min="1" max="30" step="1" value="1" style="width:48px;">分</label>
    <button id="fsBtn" class="pill" title="全画面にする">全画面</button>
  </div>

  <p><small>ヒント：上半身と机が映るように端末を置いてください。ホーム画面に追加（PWA化）すると安定します。</small></p>

  <details>
    <summary>ログ</summary>
    <div id="log"></div>
  </details>
</main>

<!-- 全画面時の浮遊操作バー -->
<div class="floating-bar" style="display:none;">
  <button id="fsStart">開始</button>
  <button id="fsStop" disabled>停止</button>
  <button id="fsExit">全画面解除</button>
</div>

<script>
/* ====== 設定：あなたのGAS WebアプリURLに差し替え ====== */
const GAS_ENDPOINT = "https://script.google.com/macros/s/AKfycby2tE_Xq1tm_NSDQVQYB52gIEb4_T5DxrYoYkbYbgdV-djRMFuFcqengAP9aWOhlKW4/exec";
/* ======================================================== */

const ui = {
  video: document.getElementById('video'),
  startBtn: document.getElementById('startBtn'),
  stopBtn: document.getElementById('stopBtn'),
  statePill: document.getElementById('statePill'),
  personPill: document.getElementById('personPill'),
  phonePill: document.getElementById('phonePill'),
  scorePill: document.getElementById('scorePill'),
  minutePill: document.getElementById('minutePill'),
  presence: document.getElementById('presence'),
  flush: document.getElementById('flush'),
  log: document.getElementById('log'),
  fsBtn: document.getElementById('fsBtn'),
  fsBar: document.querySelector('.floating-bar'),
  fsStart: document.getElementById('fsStart'),
  fsStop: document.getElementById('fsStop'),
  fsExit: document.getElementById('fsExit'),
};

let stream=null, wakeLock=null, running=false;
let tickTimer=null, flushTimer=null;
let model=null;

let samples=0, studySamples=0, studiedMinutes=Number(localStorage.getItem('studiedMinutes')||0);
updateMinutePill();

/* ----------------- 依存（TFJS + COCO-SSD）読み込み ----------------- */
/* jsDelivr → unpkg の順に試す（CDNブロック対策） */
async function loadScriptTry(urls){
  let lastErr;
  for (const src of urls){
    try{
      await new Promise((res, rej)=>{
        const s=document.createElement('script');
        s.src=src; s.defer=true; s.onload=res;
        s.onerror=()=>rej(new Error('load failed: '+src));
        document.head.appendChild(s);
      });
      log('loaded: ' + src);
      return;
    }catch(e){ lastErr=e; log('CDN load error: '+src); }
  }
  throw lastErr || new Error('all CDN failed');
}

async function loadDeps(){
  await loadScriptTry([
    'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js',
    'https://unpkg.com/@tensorflow/tfjs@4.15.0/dist/tf.min.js'
  ]);
  await loadScriptTry([
    'https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js',
    'https://unpkg.com/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js'
  ]);
}

/* ----------------- UIボタン ----------------- */
ui.startBtn.addEventListener('click', start);
ui.stopBtn.addEventListener('click', stop);
ui.fsStart.addEventListener('click', start);
ui.fsStop .addEventListener('click', stop);
ui.fsBtn.addEventListener('click', toggleFullscreen);
ui.fsExit.addEventListener('click', exitFullscreen);

/* ----------------- フルスクリーン ----------------- */
async function toggleFullscreen(){
  if (!document.fullscreenElement) await enterFullscreen();
  else await exitFullscreen();
}
async function enterFullscreen(){
  try {
    (document.documentElement.requestFullscreen && await document.documentElement.requestFullscreen())
      || (document.body.requestFullscreen && await document.body.requestFullscreen());
  } catch {}
  document.body.classList.add('fs');
  ui.fsBar.style.display = 'flex';
  try { if (screen.orientation && screen.orientation.lock) await screen.orientation.lock('portrait'); } catch {}
}
async function exitFullscreen(){
  try { if (document.fullscreenElement) await document.exitFullscreen(); } catch {}
  document.body.classList.remove('fs');
  ui.fsBar.style.display = 'none';
}

/* ----------------- 開始/停止 ----------------- */
async function start(){
  if (running) return;
  running = true;
  ui.startBtn.disabled = true;
  ui.stopBtn.disabled = false;
  ui.fsStart.disabled = true;
  ui.fsStop.disabled = false;
  setState(true);

  // 1) カメラ
  try {
    log('[1] starting camera...');
    await startCamera();
    log('[1] camera ready');
  } catch (e) {
    log('NG at camera: ' + (e?.message || e));
    setState(false);
    ui.startBtn.disabled=false; ui.stopBtn.disabled=true;
    ui.fsStart.disabled=false; ui.fsStop.disabled=true;
    running=false;
    return;
  }

  // 2) 依存
  try { log('[2] loading deps...'); await loadDeps(); log('[2] deps loaded'); }
  catch(e){ log('NG at loadDeps: ' + (e?.message||e) + '（在席のみで継続）'); }

  // 3) モデル
  try {
    log('[3] loading model...');
    model = await window.cocoSsd.load({base:'lite_mobilenet_v2'}); // 軽量構成
    log('[3] model ready');
  } catch(e){
    log('NG at model load: ' + (e?.message||e) + '（在席のみで継続）');
  }

  try { await requestWakeLock(); } catch {}
  tickTimer = setInterval(tick, 1000);  // 1秒ごと推論
  scheduleFlush();                      // 1分ごと送信（UI変更可）
  log('STARTED');
}

async function stop(){
  running=false;
  clearInterval(tickTimer); clearInterval(flushTimer);
  await releaseWakeLock();
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
  ui.video.srcObject=null;
  setState(false);
  ui.startBtn.disabled=false; ui.stopBtn.disabled=true;
  ui.fsStart.disabled=false; ui.fsStop.disabled=true;
  await flushReport(true); // 残り送信
  log('STOPPED');
}

/* ----------------- カメラ ----------------- */
async function startCamera(){
  stream = await navigator.mediaDevices.getUserMedia({
    video:{ facingMode:'user', width:{ideal:640}, height:{ideal:480} }, audio:false
  });
  ui.video.srcObject=stream; await ui.video.play();
}

/* ----------------- 毎秒の判定 ----------------- */
async function tick(){
  if(!running) return;
  samples++;

  let hasPerson=false, hasPhone=false;

  try{
    if (model) {
      const preds = await model.detect(ui.video);
      hasPerson = preds.some(p => p.class === 'person' && p.score >= 0.6);
      hasPhone  = preds.some(p => (p.class === 'cell phone' || p.class === 'mobile phone') && p.score >= 0.6);
    } else {
      // モデル無しの場合は「在席のみ」でゆるく判定（動画が流れていれば在席扱い）
      hasPerson = !!ui.video.srcObject;
      hasPhone  = false;
    }
  }catch(e){
    // 推論失敗は無視（在席のみ継続）
  }

  setPill(ui.personPill, '人', hasPerson);
  setPill(ui.phonePill,  'スマホ', hasPhone);

  // スコア: 人検出を主、スマホ検出で減点
  const base = hasPerson ? 100 : 0;
  const penalty = hasPhone ? 40 : 0;
  const score = Math.max(0, Math.min(100, base - penalty));
  ui.scorePill.textContent = `スコア: ${score}`;

  if (score >= 60) studySamples++;

  if (samples >= 60){
    const ratio = (studySamples/samples)*100;
    const th = clamp(Number(ui.presence.value)||70, 50, 100);
    if (ratio >= th){
      studiedMinutes++;
      localStorage.setItem('studiedMinutes', String(studiedMinutes));
      updateMinutePill();
      log(`+1分（勉強フレーム率 ${ratio.toFixed(0)}% >= しきい値 ${th}%）`);
    }else{
      log(`加算なし（勉強フレーム率 ${ratio.toFixed(0)}% < しきい値 ${th}%）`);
    }
    samples=0; studySamples=0;
  }
}

/* ----------------- 送信（デフォ1分ごと） ----------------- */
function scheduleFlush(){
  const mins = clamp(Number(ui.flush.value)||1, 1, 30);
  if (flushTimer) clearInterval(flushTimer);
  flushTimer = setInterval(()=>flushReport(false), mins*60*1000);
}

async function flushReport(force){
  const minutes = studiedMinutes;
  if (!minutes && !force) return;
  const payload = {
    type: 'study-minutes-report',
    minutes,
    ts: new Date().toISOString(),
    ua: navigator.userAgent
  };
  try{
    // プリフライト回避（text/plain）＋ 失敗時no-cors保険
    await fetch(GAS_ENDPOINT, {
      method:'POST',
      headers:{'Content-Type':'text/plain'},
      body: JSON.stringify(payload),
      keepalive: true
    }).catch(async ()=>{
      await fetch(GAS_ENDPOINT, {
        method:'POST', mode:'no-cors',
        body: JSON.stringify(payload), keepalive:true
      });
    });
    log(`送信: ${minutes} 分`);
    studiedMinutes=0; localStorage.setItem('studiedMinutes','0'); updateMinutePill();
  }catch(e){
    log('送信失敗: ' + (e?.message||e) + '（次回再送）');
  }
}

/* ----------------- Wake Lock ----------------- */
async function requestWakeLock(){ if('wakeLock' in navigator){ try{ wakeLock = await navigator.wakeLock.request('screen'); }catch{} } }
async function releaseWakeLock(){ try { if (wakeLock) await wakeLock.release(); } catch {} }

/* ----------------- ヘルパ ----------------- */
function setState(active){ ui.statePill.textContent=active?'監視中':'停止中'; ui.statePill.className='pill '+(active?'ok':'ng'); }
function setPill(el, label, on){ el.textContent = `${label}: ${on?'検出':'未検出'}`; el.className='pill '+(on?'ok':'ng'); }
function updateMinutePill(){ ui.minutePill.textContent=`勉強分: ${studiedMinutes}`; }
function log(s){ ui.log.textContent += `[${new Date().toLocaleTimeString()}] ${s}\n`; }
function clamp(v,lo,hi){ return Math.max(lo, Math.min(hi,v)); }

/* 背景化での自動停止は一旦オフ（端末によって誤停止しがち） */
// document.addEventListener('visibilitychange', ()=>{ if(document.hidden && running){ log('背景化→停止'); stop(); }});

function applyOrientation(){
  const landscape = window.matchMedia('(orientation: landscape)').matches;
  document.body.classList.toggle('landscape', landscape);
}
window.addEventListener('resize', applyOrientation);
window.addEventListener('orientationchange', applyOrientation);
applyOrientation();
</script>
</body>
</html>
