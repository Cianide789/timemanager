<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Study Watcher Pro</title>
<style>
  :root { color-scheme: light dark; }
  html, body { height: 100%; }
  body { margin: 0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Sans", "Noto Sans JP", sans-serif; background: Canvas; color: CanvasText; }
  header { padding: 12px 16px; border-bottom: 1px solid #ddd; position: sticky; top: 0; background: inherit; z-index: 2; }
  main { padding: 12px 16px; }
  .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
  video { width: 100%; max-height: 44vh; background: #000; border-radius: 12px; }
  .pill { padding: 6px 10px; border-radius: 999px; border: 1px solid #ccc; font-size: 14px; }
  .ok { background: #e7f7ee; border-color: #a3d8bf; }
  .ng { background: #fdeaea; border-color: #f2b7b7; }
  button { padding: 10px 14px; border-radius: 10px; border: 1px solid #ccc; font-size: 16px; background: ButtonFace; color: ButtonText; }
  .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px; }
  small { color: #666; }
  #log { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; opacity: .85; }
  /* フルスクリーン時の見た目 */
  .fs header { display: none; }
  .fs main { padding: 0; }
  .fs video { max-height: none; height: 100vh; border-radius: 0; }
  .fs .floating-bar { position: fixed; bottom: 10px; left: 0; right: 0; display: flex; gap: 8px; justify-content: center; z-index: 3; }
  .floating-bar button { opacity: .85; backdrop-filter: blur(6px); }
</style>
</head>
<body>
<header>
  <div class="row">
    <strong>Study Watcher Pro</strong>
    <span id="statePill" class="pill ng">停止中</span>
    <span id="facePill" class="pill">顔: 未検出</span>
    <span id="scorePill" class="pill">スコア: 0</span>
    <span id="minutePill" class="pill">勉強分: 0</span>
  </div>
</header>

<main>
  <video id="video" playsinline muted></video>

  <div class="grid">
    <button id="startBtn">開始</button>
    <button id="stopBtn" disabled>停止</button>
  </div>

  <div class="row" style="margin-top:8px;">
    <label class="pill">在席しきい値: <input id="presence" type="number" min="50" max="100" step="5" value="70" style="width:64px;">%</label>
    <label class="pill">送信間隔: <input id="flush" type="number" min="1" max="30" step="1" value="1" style="width:48px;">分</label>
    <button id="fsBtn" class="pill" title="全画面にする">全画面</button>
  </div>

  <p><small>ヒント：顔＋上半身＋机が入るように端末を置いてください。ホーム画面に追加（PWA化）すると安定します。</small></p>

  <details>
    <summary>ログ</summary>
    <div id="log"></div>
  </details>
</main>

<!-- 全画面時に浮かせる操作バー（開始/停止/終了） -->
<div class="floating-bar" style="display:none;">
  <button id="fsStart">開始</button>
  <button id="fsStop" disabled>停止</button>
  <button id="fsExit">全画面解除</button>
</div>

<script>
/* ===== 設定（あなたのGAS URLを入れてね） ===== */
const GAS_ENDPOINT = "https://script.google.com/macros/s/REPLACE_WITH_YOUR_DEPLOYED_WEB_APP_URL/exec";
/* ============================================== */

const ui = {
  video: document.getElementById('video'),
  startBtn: document.getElementById('startBtn'),
  stopBtn: document.getElementById('stopBtn'),
  statePill: document.getElementById('statePill'),
  facePill: document.getElementById('facePill'),
  scorePill: document.getElementById('scorePill'),
  minutePill: document.getElementById('minutePill'),
  presence: document.getElementById('presence'),
  flush: document.getElementById('flush'),
  log: document.getElementById('log'),
  fsBtn: document.getElementById('fsBtn'),
  fsBar: document.querySelector('.floating-bar'),
  fsStart: document.getElementById('fsStart'),
  fsStop: document.getElementById('fsStop'),
  fsExit: document.getElementById('fsExit'),
};

let stream=null, wakeLock=null, running=false;
let tickTimer=null, flushTimer=null;

let faceDetector=null, poseModel=null, objModel=null;
let useTFJSFace=false;

let samples=0, studySamples=0, studiedMinutes=Number(localStorage.getItem('studiedMinutes')||0);
updateMinutePill();

/* 依存の読み込み */
async function loadDeps(){
  if (!('FaceDetector' in window)) {
    await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js');
    await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/face-detection@1.0.3/dist/face-detection.min.js');
    useTFJSFace = true;
  }
  await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@3.7.0/dist/pose-detection.min.js');
  await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js');
}
function loadScript(src){
  return new Promise((resolve, reject)=>{
    const s=document.createElement('script');
    s.src=src; s.defer=true;
    s.onload=resolve;
    s.onerror=()=>{ log('CDN load error: ' + src); reject(new Error('load failed: '+src)); };
    document.head.appendChild(s);
  });
}

/* ボタン */
ui.startBtn.addEventListener('click', start);
ui.stopBtn.addEventListener('click', stop);
ui.fsStart.addEventListener('click', start);
ui.fsStop .addEventListener('click', stop);
ui.fsBtn.addEventListener('click', toggleFullscreen);
ui.fsExit.addEventListener('click', exitFullscreen);

/* 全画面 */
async function toggleFullscreen(){
  if (!document.fullscreenElement) {
    await enterFullscreen();
  } else {
    await exitFullscreen();
  }
}
async function enterFullscreen(){
  try {
    (document.documentElement.requestFullscreen && await document.documentElement.requestFullscreen())
      || (document.body.requestFullscreen && await document.body.requestFullscreen());
  } catch {}
  document.body.classList.add('fs');
  ui.fsBar.style.display = 'flex';
  // 端末が対応してたら縦固定
  try { if (screen.orientation && screen.orientation.lock) await screen.orientation.lock('portrait'); } catch {}
}
async function exitFullscreen(){
  try { if (document.fullscreenElement) await document.exitFullscreen(); } catch {}
  document.body.classList.remove('fs');
  ui.fsBar.style.display = 'none';
}

/* 開始（段階的エラーハンドリング） */
async function start(){
  if (running) return;
  running = true;
  ui.startBtn.disabled = true;
  ui.stopBtn.disabled = false;
  ui.fsStart.disabled = true;
  ui.fsStop.disabled = false;
  setState(true);

  // 1) カメラ：ここだけ失敗したら停止
  try {
    log('[1] starting camera...');
    await startCamera();
    log('[1] camera ready');
  } catch (e) {
    log('NG at camera: ' + (e && (e.message || e.name || e.toString())));
    setState(false);
    ui.startBtn.disabled=false; ui.stopBtn.disabled=true;
    ui.fsStart.disabled=false; ui.fsStop.disabled=true;
    running=false;
    return;
  }

  // 2) 依存読み込み：失敗しても在席のみで継続
  try { log('[2] loading deps...'); await loadDeps(); log('[2] deps loaded'); }
  catch (e) { log('NG at loadDeps: ' + (e && (e.message || e.name || e.toString())) + '（在席のみで継続）'); }

  // 3) モデル初期化：失敗しても継続
  try { log('[3] init models...'); await initModels(); log('[3] models ready'); }
  catch (e) { log('NG at initModels: ' + (e && (e.message || e.name || e.toString())) + '（在席のみで継続）'); }

  try { await requestWakeLock(); } catch {}
  tickTimer = setInterval(tick, 1000);
  scheduleFlush(); // ← デフォルト 1分
  log('STARTED');
}

/* 停止 */
async function stop(){
  running=false;
  clearInterval(tickTimer); clearInterval(flushTimer);
  await releaseWakeLock();
  if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
  ui.video.srcObject=null;
  setState(false);
  ui.startBtn.disabled=false; ui.stopBtn.disabled=true;
  ui.fsStart.disabled=false; ui.fsStop.disabled=true;
  await flushReport(true); // 残りを送る
  log('STOPPED');
}

/* カメラ */
async function startCamera(){
  stream = await navigator.mediaDevices.getUserMedia({
    video:{ facingMode:'user', width:{ideal:640}, height:{ideal:480}, frameRate:{ideal:30,max:30} }, audio:false
  });
  ui.video.srcObject=stream; await ui.video.play();
}

/* モデル初期化 */
async function initModels(){
  if ('FaceDetector' in window){
    faceDetector = new window.FaceDetector({ fastMode:true });
  } else if (window.faceDetection) {
    const { MediaPipeFaceDetector, SupportedModels } = window.faceDetection;
    faceDetector = await MediaPipeFaceDetector.create({ runtime:'tfjs', model: SupportedModels.MediaPipeFaceDetector, maxFaces:1 });
  }
  if (window.poseDetection){
    const { SupportedModels, createDetector } = window.poseDetection;
    poseModel = await createDetector(SupportedModels.MoveNet, { modelType: 'Thunder' });
  }
  if (window.cocoSsd){
    objModel = await cocoSsd.load();
  }
}

/* 1秒ごとに判定 */
async function tick(){
  if(!running) return;
  samples++;

  const hasFace = await detectFace();
  setFacePill(hasFace);

  let poseScore = 0, phonePenalty = 0;
  if (hasFace){
    poseScore = await postureScore();
    phonePenalty = await phoneScore();
  }

  const score = Math.max(0, Math.min(100, Math.round( (poseScore*0.7 + (hasFace?100:0)*0.3) - phonePenalty*40 )));
  ui.scorePill.textContent = `スコア: ${score}`;

  if (score >= 60) studySamples++;

  if (samples >= 60){
    const ratio = (studySamples/samples)*100;
    const th = clamp(Number(ui.presence.value)||70, 50, 100);
    if (ratio >= th){
      studiedMinutes++;
      localStorage.setItem('studiedMinutes', String(studiedMinutes));
      updateMinutePill();
      log(`+1分（勉強フレーム率 ${ratio.toFixed(0)}% >= しきい値 ${th}%）`);
    }else{
      log(`加算なし（勉強フレーム率 ${ratio.toFixed(0)}% < しきい値 ${th}%）`);
    }
    samples=0; studySamples=0;
  }
}

async function detectFace(){
  try{
    if (faceDetector && faceDetector.detect) {
      const r = await faceDetector.detect(ui.video);
      return r && r.length>0;
    } else if (faceDetector && faceDetector.estimateFaces) {
      const r = await faceDetector.estimateFaces(ui.video, { flipHorizontal:true });
      return r && r.length>0;
    } else {
      // 依存がない場合は「在席のみ」＝映像が再生されていれば在席扱い
      return !!ui.video.srcObject;
    }
  }catch{ return false; }
}

async function postureScore(){
  try{
    if (!poseModel || !poseModel.estimatePoses) return 50; // 中立
    const poses = await poseModel.estimatePoses(ui.video, { flipHorizontal:true });
    if (!poses || !poses[0] || !poses[0].keypoints) return 50;
    const k = Object.fromEntries(poses[0].keypoints.map(p=>[p.name||p.part, p]));
    const nose=k.nose, le=k.left_eye||k.leftEye, re=k.right_eye||k.rightEye, leEar=k.left_ear||k.leftEar, reEar=k.right_ear||k.rightEar, ls=k.left_shoulder||k.leftShoulder, rs=k.right_shoulder||k.rightShoulder, lw=k.left_wrist||k.leftWrist, rw=k.right_wrist||k.rightWrist;

    if(!ls||!rs) return 50;

    const headTilt = (()=>{ // 下向き軽く加点、上向き減点
      const eyesY = avg([le?.y, re?.y].filter(v=>isFinite(v)));
      const earsY = avg([leEar?.y, reEar?.y].filter(v=>isFinite(v)));
      if (!isFinite(eyesY) || !isFinite(earsY)) return 50;
      const d = eyesY - earsY; // 正で下向き
      return clamp(50 + d*0.2, 0, 100);
    })();

    const shoulderSlope = Math.atan2((ls.y - rs.y), (ls.x - rs.x));
    const stability = 100 - Math.min(100, Math.abs(shoulderSlope)*120);

    const vh = ui.video.videoHeight || 480;
    const deskY = vh * (2/3);
    let handsAtDesk = 0;
    [lw, rw].forEach(w=>{ if(w && w.y>=deskY) handsAtDesk+=1; });
    const handsScore = [0, 60, 100][handsAtDesk] ?? 0;

    return Math.round( headTilt*0.35 + stability*0.25 + handsScore*0.40 );
  }catch{ return 50; }
}

async function phoneScore(){
  try{
    if (!objModel || !objModel.detect) return 0;
    const preds = await objModel.detect(ui.video);
    const phone = preds.find(p=>p.class==='cell phone' && p.score>=0.6);
    return phone ? Math.min(1, phone.score) : 0;
  }catch{ return 0; }
}

/* 送信（デフォルト1分ごと） */
function scheduleFlush(){
  const mins = clamp(Number(ui.flush.value)||1, 1, 30);
  if (flushTimer) clearInterval(flushTimer);
  flushTimer = setInterval(()=>flushReport(false), mins*60*1000);
}

async function flushReport(force){
  const minutes = studiedMinutes;
  if (!minutes && !force) return;
  const payload = {
    type: 'study-minutes-report',
    minutes,
    ts: new Date().toISOString(),
    ua: navigator.userAgent
  };
  try{
    await fetch(GAS_ENDPOINT, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify(payload)
      // CORSエラーが出る場合は一時的に mode:'no-cors' を付けて“投げっぱなし”にできます
    });
    log(`送信: ${minutes} 分`);
    studiedMinutes=0; localStorage.setItem('studiedMinutes','0'); updateMinutePill();
  }catch(e){
    log('送信失敗: ' + (e && (e.message || e.name || e.toString())) + '（次回再送）');
  }
}

/* Wake Lock */
async function requestWakeLock(){ if('wakeLock' in navigator){ try{ wakeLock = await navigator.wakeLock.request('screen'); }catch{} } }
async function releaseWakeLock(){ try { if (wakeLock) await wakeLock.release(); } catch {} }

/* UIヘルパ */
function setState(active){ ui.statePill.textContent=active?'監視中':'停止中'; ui.statePill.className='pill '+(active?'ok':'ng'); }
function setFacePill(has){ ui.facePill.textContent=has?'顔: 検出':'顔: 未検出'; ui.facePill.className='pill '+(has?'ok':'ng'); }
function updateMinutePill(){ ui.minutePill.textContent=`勉強分: ${studiedMinutes}`; }
function log(s){ ui.log.textContent += `[${new Date().toLocaleTimeString()}] ${s}\n`; }
function clamp(v,lo,hi){ return Math.max(lo, Math.min(hi,v)); }
function avg(a){ return a.length? a.reduce((x,y)=>x+y,0)/a.length : NaN; }

/* デバッグ中に誤停止する端末があるので、背景化即停止は一旦オフ */
// document.addEventListener('visibilitychange', ()=>{ if(document.hidden && running){ log('背景化→停止'); stop(); }});
</script>
</body>
</html>
